<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lca_grupa_avansata</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="lowest-common-ancestor">Lowest Common Ancestor</h1>
<h3 id="autor-bogdan-iordache">autor: Bogdan Iordache</h3>
<h2 id="definitie">Definitie</h2>
<p>Fie <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathnormal">T</span></span></span></span></span> un arbore cu radacina, si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> doua noduri din <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathnormal">T</span></span></span></span></span>. Numim “cel mai apropiat stramos comun”/“lowest common ancestor” (i.e. LCA) al nodurilor <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> acel nod <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.04398em;" class="mord mathnormal">z</span></span></span></span></span> cu proprietatea ca <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.04398em;" class="mord mathnormal">z</span></span></span></span></span> este stramos al lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si al lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> si este nodul de adancime maxima din <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathnormal">T</span></span></span></span></span> cu aceasta proprietate.</p>
<h2 id="exemplu">Exemplu</h2>
<p><img src="imgs/lca_nivel_avansat/arbore.png" alt=""><br>
Notam <code>LCA(x, y)</code> cel mai apropiat stramos comun al nodurilor <code>x</code> si <code>y</code>.<br>
Vom considere, pentru simplitate, si fara a restrange generalitatea, ca toti arborii vor avea ca radacina nodul <code>1</code>.</p>
<p>In figura de mai sus:</p>
<ul>
<li><code>LCA(3, 4) = 2</code></li>
<li><code>LCA(10, 11) = 5</code></li>
<li><code>LCA(4, 7) = 1</code></li>
<li><code>LCA(7, 8) = 5</code></li>
<li><code>LCA(9, 5) = 5</code></li>
</ul>
<p><em>Explicatie pentru</em> <code>LCA(10, 11)</code>: exista doua noduri care sunt stramosi atat pentru <code>10</code> cat si pentru <code>11</code> (nodurile <code>1</code> si <code>5</code>); dintrea acestea <code>5</code> are adancime maxima.</p>
<p><strong>Obs.</strong> Un nod se considera stramos al lui insusi, deci daca <code>x</code> este stramos al lui <code>y</code>, atunci <code>LCA(x, y) = x</code>.</p>
<h3 id="exemple-de-aplicatii">Exemple de aplicatii</h3>
<ol>
<li>O aplicatie evidenta este determinarea lungimii drumului minim dintre doua noduri <code>x</code> si <code>y</code>. Daca notam cu <code>nivel[x]</code> adancimea nodului <code>x</code>, avem lungimea drumului de la <code>x</code> la <code>y</code>:<br>
<code>nivel[x] + nivel[y] - 2 * nivel[LCA(x, y)]</code></li>
<li>Aplicatiile practice sunt nenumarate, un exemplu din lingvistica istorica ar fi determinarea celui mai apropiat stramos a doua cuvinte din limbi diferite (cu alte cuvinte “care este cel mai recent cuvant din care au fost derivate ambele cuvinte date?”)<br>
<img src="imgs/lca_nivel_avansat/historical.webp" alt=""></li>
</ol>
<h2 id="algoritmi-pentru-determinarea-lca">Algoritmi pentru determinarea LCA</h2>
<p>Problema o putem defini in general astfel:</p>
<ul>
<li>avem un arbore cu <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span></span></span></span></span> noduri si radacina in nodul <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>;</li>
<li>se dau <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">Q</span></span></span></span></span> intrebari de forma <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span><span class="mclose">)</span></span></span></span></span>, determinati <code>LCA(x, y)</code>.</li>
</ul>
<p>Ca referinta vom folosi problema LCA (<a href="https://infoarena.ro/problema/lca">infoarena</a>).</p>
<h3 id="complexitate-oq-cdot-n">Complexitate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>Q</mi><mo>⋅</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Q \cdot N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span></h3>
<p>Aceasta solutie este o abordare simpla care functioneaza astfel:</p>
<ul>
<li>pentru o intrebare <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span><span class="mclose">)</span></span></span></span></span> consideram fara a restrange generalitatea ca <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> se afla la o adancima mai mare sau egala decat adancimea lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span>;</li>
<li>cat timp <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> se afla la o adancime mai mare sau egala cu adancimea lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span>, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> devine parintele lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> din arbore (urcam cu cate un nivel)</li>
<li>avand acum <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> la aceeasi adancime, cat timp sunt diferite vom “urca” ambele noduri cu cate un nivel (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> devine parintele lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, iar <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> devine parintele lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span>).</li>
<li>valoarea egala a lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> de la finalul iteratiilor de mai sus este <code>LCA(x, y)</code>.</li>
</ul>
<p>Notam cu <code>parinte[i]</code> parintele din arbore al nodului <code>i</code>.<br>
Notam cu <code>nivel[i]</code> adancimea nodului <code>i</code>.<br>
Notam cu <code>arbore[i]</code> lista de fii (descendenti directi) ai nodului <code>i</code> (implementata folosind <code>std::vector</code> din C++).</p>
<p><code>nivel</code> se poate calcula usor printr-o parcurgere DF:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> nod<span class="token punctuation">,</span> <span class="token keyword">int</span> nvl <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    nivel<span class="token punctuation">[</span>nod<span class="token punctuation">]</span> <span class="token operator">=</span> nvl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fiu <span class="token operator">:</span> arbore<span class="token punctuation">[</span>nod<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>fiu<span class="token punctuation">,</span> nvl <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Determinarea LCA-ului pentru doua noduri se poate implementa astfel:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">int</span> <span class="token function">lca</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nivel<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nivel<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nivel<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nivel<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        x <span class="token operator">=</span> parinte<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> y<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        x <span class="token operator">=</span> parinte<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
        y <span class="token operator">=</span> parinte<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>O implementare completa a acestei solutii puteti gasi <a href="https://infoarena.ro/job_detail/2970841?action=view-source">aici</a>.</p>
<h3 id="complexitate-onlog-n--qlog-n">Complexitate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>Q</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N + Q\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span></h3>
<h4 id="liniarizarea-arborelui">Liniarizarea arborelui</h4>
<p>Pentru a putea explica aceasta solutie mai usor vom face o scurta precizare legata de parcurgerea DF a unui arbore.</p>
<p><img src="imgs/lca_nivel_avansat/euler.png" alt=""><br>
Notam intr-o lista nodurile prin care trecem (adaugam un nod atunci cand ajungem cu parcurgerea prima oara la el, si il mai adaugam atunci cand apelul recursiv pentru el ia sfarsit):<br>
<code>[1, 2, 3, 3, 4, 4, 2, 5, 6, 9, 9, 10, 10, 6, 7, 7, 8, 11, 11, 8, 5, 1]</code></p>
<p>Fiecare nod apare de exact 2 ori. Notam cu <code>p_start[i]</code> prima pozitie pe care apare nodul <code>i</code> in lista si cu <code>p_end[i]</code> ultima pozitie pe care apare <code>i</code>. Astfel pentru un nod <code>i</code> avem definit un interval <code>[p_start[i], p_end[i]]</code>.</p>
<p>O observatie esentiala este ca pentru doua noduri <code>x</code> si <code>y</code> avem <code>x</code> stramos al lui <code>y</code> <strong>daca si numai daca</strong> intervalul lui <code>x</code> include intervalul lui <code>y</code>.</p>
<p>Putem determina liniarizarea de mai sus chiar in timpul pargurgerii DF:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">int</span> p_curent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p_start<span class="token punctuation">[</span>MAX_N<span class="token punctuation">]</span><span class="token punctuation">,</span> p_end<span class="token punctuation">[</span>MAX_N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> nod<span class="token punctuation">,</span> <span class="token keyword">int</span> nvl <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    nivel<span class="token punctuation">[</span>nod<span class="token punctuation">]</span> <span class="token operator">=</span> nvl<span class="token punctuation">;</span>
    p_start<span class="token punctuation">[</span>nod<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>p_curent<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fiu <span class="token operator">:</span> arbore<span class="token punctuation">[</span>nod<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>fiu<span class="token punctuation">,</span> nvl <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    p_end<span class="token punctuation">[</span>nod<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>p_curent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Si putem verifica usor daca un nod este stramos al altuia:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">bool</span> <span class="token function">este_stramos</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// return true &lt;=&gt; x este stramos al lui y</span>
    <span class="token keyword">return</span> p_start<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> p_start<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> p_end<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> p_end<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="problema-stramosi-infoarena">Problema “Stramosi” (<a href="https://infoarena.ro/problema/stramosi">infoarena</a>)</h4>
<p>Mentionam aceasta problema intrucat tehnica aplicata aici este esentiala pentru solutia noastra la problema determinarii LCA.</p>
<p>Pe scurt, problema cere pentru un nod <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, care este al <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathnormal">k</span></span></span></span></span>-lea stramos al sau (pentru <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathnormal">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> raspunsul este parintele lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, pentru <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathnormal">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span> parintele parintelui lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> s.a.m.d.).</p>
<p>O solutie la o astfel de intrebare in complexitate timp <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.03148em;" class="mord mathnormal">k</span><span class="mclose">)</span></span></span></span></span> este triviala (iteram din parinte in parinte de <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathnormal">k</span></span></span></span></span> ori).</p>
<p>O solutie mult mai eficienta se realizeaza prin precalcularea urmatoarei tabele:<br>
<code>stramos[p][nod] :=</code> al <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span>-lea stramos al nodului <code>nod</code> (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> daca nu exista un astfel de stramos).</p>
<p>Determinarea acestei tabele se poate realiza astfel:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">void</span> <span class="token function">calculeaza_stramosi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> nod <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> nod <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>nod<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        stramos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>nod<span class="token punctuation">]</span> <span class="token operator">=</span> parinte<span class="token punctuation">[</span>nod<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> MAX_LOG<span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> nod <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> nod <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>nod<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            stramos<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>nod<span class="token punctuation">]</span> <span class="token operator">=</span> stramos<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>stramos<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>nod<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Determinarea celui de-al <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathnormal">k</span></span></span></span></span>-lea stramos se reduce acum la scrierea lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathnormal">k</span></span></span></span></span> in baza <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span>:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">int</span> <span class="token function">gaseste_stramos</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> MAX_LOG<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
	          x <span class="token operator">=</span> stramos<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="stramosi-pentru-lca">“Stramosi” pentru LCA</h4>
<p>Revenim acum la determinarea LCA. Fie nodurile <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> pentru care vrems a determinam LCA. Vom lasa la o parte cazurile in care fie <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> este stramos al lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span>, fie <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> este stramos al lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>. Aceste cazuri pot fi verificate usor folosind functia <code>este_stramos</code>.</p>
<p>Ideea ce sta la baza solutiei este faptul ca putem cauta binar stramosul de adancime <strong>minima</strong> al lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> care <strong>NU</strong> este stramos al lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span>. Automat, aprintele acestui nod este stramosul comun de adancime <strong>maxima</strong> (LCA) al nodurilor <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span>.</p>
<p>Cautarea binara se poate face “pe biti” folosind tabela <code>stramos</code>:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">int</span> <span class="token function">lca</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">este_stramos</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">este_stramos</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> MAX_LOG <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> z <span class="token operator">=</span> stramos<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">este_stramos</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            x <span class="token operator">=</span> z<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> stramos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Cu alte cuvinte, fixam pe rand cate un bit (incepand cu cel mai semnificativ) al distantei de la <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> pana la nodul de adancime minima care nu este stramos al lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span>.</p>
<p>Complexitatea este data de calculul tabelei <code>stramos</code>, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span> si de complexitatea functiei <code>lca</code> aplicata pentru fiecare interogare, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Q</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Q\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span>.</p>
<p>O implementare completa a acestei solutii puteti gasi <a href="https://infoarena.ro/job_detail/2970853?action=view-source">aici</a>.</p>
<h3 id="complexitate-onlog-n--q">Complexitate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N + Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)</span></span></span></span></span></h3>
<p><strong>!!!</strong> Pentru aceasta solutie avem nevoie de cunostinte legate de Range Minimum Query (<a href="https://cppi.sync.ro/materia/rmq_range_minimum_query.html">RMQ</a>).</p>
<p>Consideram parcurgearea DF de mai devreme:<br>
<img src="imgs/lca_nivel_avansat/euler.png" alt=""><br>
Vom nota acum nodurile de fiecare data cand ajungem la ele (fie prima oara, fie la fiecare intoarcere din cate un fiu). De asemenea, retinem pentru fiecare nod si nivelul sau intr-un tabel.</p>

<table>
<thead>
<tr>
<th>nod</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>2</th>
<th>4</th>
<th>2</th>
<th>1</th>
<th>5</th>
<th>6</th>
<th>9</th>
<th>6</th>
<th>10</th>
<th>6</th>
<th>5</th>
<th>7</th>
<th>5</th>
<th>8</th>
<th>11</th>
<th>8</th>
<th>5</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>nivel</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>3</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table><p>Notam cu <code>p_start[i]</code> prima pozitie din lista de mai sus pe care apare nodul <code>i</code>.</p>
<p>Fie acum doua noduri oarecare <code>x</code> si <code>y</code>. Intervalul dintre pozitiile <code>p_start[x]</code> si <code>p_start[y]</code> va contine cel putin o aparitie a nodului <code>z = LCA(x, y)</code> si, mai mult, niciun alt stramos comun al nodurilor <code>x</code> si <code>y</code> nu va aparea in acest interval.</p>
<p>Motivul este destul de usor de intuit: nodurile <code>x</code> si <code>y</code> sunt parcurse atunci cand DF-ul proceseaza subarborele lui <code>z</code>. Din momentul in care parcurgerea ajunge in <code>z</code> nu va mai parasi subarborele acestuia pana cand nu il viziteaza pe tot.</p>
<p>Am redus astfel acum problema determinarii LCA la o problema de minim pe interval din lista de mai sus. <code>LCA(x, y)</code> nodul de nivel minim din intervalul <code>[p_start[x], p_start[y]]</code> (considerand ca <code>p_start[x] &lt;= p_start[y]</code>).</p>
<p>Cu alte cuvinte putem calcula o tabela RMQ si putem raspunde la astfel de intrebari in <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>.</p>
<p>Ca detalii de implementare, vom retine o matrice <code>rmq[p][i]</code> care va contine nodul (alaturi de nivelul acestuia) cu nivel minim din intervalul de pozitii <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>p</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, i + 2^p - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.747722em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>.</p>
<p>Initializarea pentru <code>rmq[0][i]</code> se face inca de la inceput, la parcurgerea DF:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">struct</span> RmqItem
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> nod<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nvl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> p_curent<span class="token punctuation">;</span>
<span class="token keyword">int</span> p_start<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAX_N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// lista generata de parcurgerea DF are exact 2 * N - 1 pozitii</span>
RmqItem rmq<span class="token punctuation">[</span>MAX_LOG<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAX_N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> nod<span class="token punctuation">,</span> <span class="token keyword">int</span> nvl <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    rmq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">++</span>p_curent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>nod<span class="token punctuation">,</span> nvl<span class="token punctuation">}</span><span class="token punctuation">;</span>
    p_start<span class="token punctuation">[</span>nod<span class="token punctuation">]</span> <span class="token operator">=</span> p_curent<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fiu <span class="token operator">:</span> arbore<span class="token punctuation">[</span>nod<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>fiu<span class="token punctuation">,</span> nvl <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rmq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">++</span>p_curent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>nod<span class="token punctuation">,</span> nvl<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Calculul restului de linii se face folosind algoritmul clasic pentru RMQ:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">void</span> <span class="token function">calculeaza_rmq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> MAX_LOG<span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> p_curent<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            RmqItem st <span class="token operator">=</span> rmq<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> p_curent<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                RmqItem dr <span class="token operator">=</span> rmq<span class="token punctuation">[</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                rmq<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> st<span class="token punctuation">.</span>nvl <span class="token operator">&lt;</span> dr<span class="token punctuation">.</span>nvl <span class="token operator">?</span> st <span class="token operator">:</span> dr<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                rmq<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> st<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Pentru a raspunde la o interogare in <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> trebuie sa precalculam pentru o lungime oarecare de interval care este cea mai mare putere a lui <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span> mai mica sau egala cu ea.</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">int</span> max_bit<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAX_N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">calculeaza_max_bit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// calculeaza max_bit[i] cea mai mare putere a lui 2 &lt;= i</span>
    max_bit<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> p_curent<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        max_bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max_bit<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Implementarea functiei <code>lca</code> poate fi realizata acum astfel:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">int</span> <span class="token function">lca</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> pos_x <span class="token operator">=</span> p_start<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos_y <span class="token operator">=</span> p_start<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos_x <span class="token operator">&gt;</span> pos_y<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>pos_x<span class="token punctuation">,</span> pos_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> max_bit<span class="token punctuation">[</span>pos_y <span class="token operator">-</span> pos_x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    RmqItem st <span class="token operator">=</span> rmq<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>pos_x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    RmqItem dr <span class="token operator">=</span> rmq<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>pos_y <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>nvl <span class="token operator">&lt;</span> dr<span class="token punctuation">.</span>nvl<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> st<span class="token punctuation">.</span>nod<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> dr<span class="token punctuation">.</span>nod<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>O implementare completa a acestei solutii puteti gasi <a href="https://infoarena.ro/job_detail/2970859?action=view-source">aici</a>.</p>
<h2 id="probleme">Probleme</h2>
<h3 id="pirati-infoarena">Pirati (<a href="https://infoarena.ro/problema/pirati">infoarena</a>)</h3>
<p>Numim zona conexa orice submultime maximala de celule ce contin doar apa, respectiv pamant, si se poate ajunge de la orice celula la orice alta celula mergand doar pe apa, respectiv pe pamant.</p>
<p>Consideram un graf in care fiecare astfel de zona conexa reprezinta un nod, iar muchiile reprezinta faptul ca cele doua zone au cel putin o pereche de celule adiacente in matricea initiala.</p>
<p>Exemplu (bazat pe matricea din exemplul problemei):<br>
<img src="imgs/lca_nivel_avansat/pirati.png" alt=""><br>
Se poate demonstra (usor intuitiv, putin mai dificil formal) ca acest graf este intotdeauna un arbore.</p>
<p>In mod evident toate muchiile unesc o zona de pamant (insula) cu o zona de apa. Deci pentru doua insule, numarul minim de insule ce trebuie parcurse pentru a ajunge de la una la cealalta se poate determina direct din lungimea lantului dintre nodurile lor corespunzatoare din arbore (<code>nr_insule = (lungime + 1) / 2</code>).</p>
<p>Determinarea zonelor conexe se poate realiza folosind un algoritm de tip <em>fill</em> sau folosind o parcurgere BF pornind din fiecare celula inca nevizitata si marcand toate celulele conexe de acelasi fel (apa/pamant).</p>
<p>Pentru determinarea lungimii drumurilor avem nevoie de LCA.</p>
<p>Consideram conform restrictiilor ca <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N) = O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">M</span><span class="mclose">)</span></span></span></span></span>. Observam ca adancimea maxima a arborelui corespunzator matricii de la intrare este <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span>.  Cu alte cuvinte, ne permitem sa calculam LCA cu algoritmul brut care “urca” nodurile iterativ cu cate un nivel, in <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span>.</p>
<p>Puteti gasi <a href="https://infoarena.ro/job_detail/2971294?action=view-source">aici</a> o sursa in complexitate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>+</mo><mi>N</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2 + NQ)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord"><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">NQ</span><span class="mclose">)</span></span></span></span></span>.</p>
<h3 id="ct-infoarena">CT (<a href="https://infoarena.ro/problema/ct">infoarena</a>)</h3>
<p>Problema ne cere sa determinam numarul minim de noduri pe care sa le stergem dintr-un arbore astfel incat pentru oricare pereche de noduri din input, cele doua noduri ale ei sa ajunga deconectate.</p>
<p>Pentru a deconecta nodurile <code>x</code> si <code>y</code> trebuie sa eliminam cel putin un nod de pe lantul unic dintre ele. Observam ca acest lant are doua parti “ascendente”: de la <code>x</code> la <code>LCA(x, y)</code> si de la <code>y</code> la <code>LCA(x, y)</code>.</p>
<p>Consideram perechea de noduri din input <code>(x, y)</code> cu proprietatea ca are nivelul <code>LCA(x, y)</code> maxim dintre toate perechile. Fie <code>z</code> un nod oarecare de pe lantul de la <code>x</code> la <code>y</code>. Daca eliminam <code>z</code> cele doua noduri vor deveni deconectate, si, mai mult, vom deconecta intreg subarborele lui <code>z</code> de restul arborelui. Suntem obligati sa facem o eliminare intrucat cele doua noduri nu pot fi deconectate altfel (conform modului in care le-am ales).</p>
<p>Intrucat am ales perechea cu LCA pe nivel maxim, nu exista nicio alta pereche cu ambele noduri in subarborele lui <code>z</code>. Cu alte cuvinte, daca cumva in subarborele lui <code>z</code> avem un nod din vreuna din celelalte perechi din input, acum si acea pereche este deconectata. Devine clar acum ca ne-am dori sa alegem <code>z</code> care corespunde unui subarbore cat mai mare, pentru a avea sansa de a deconecta cat mai multe alte perechi. Dar acest <code>z</code> este chiar <code>LCA(x, y)</code>.</p>
<p>Se contureaza urmatorul algoritm:</p>
<ul>
<li>sorteaza perechile de noduri <code>(x, y)</code> descrescator dupa nivelul <code>LCA(x, y)</code></li>
<li>pentru perechea curenta <code>(x, y)</code>, daca <code>x</code> sau <code>y</code> este marcat ca “deconectat”, nu avem nimic de facut (a fost deja eliminat un nod care a deconectat <code>x</code> de <code>y</code>)</li>
<li>altfel, vom elimina din arbore nodul <code>LCA(x, y)</code> si vom marca intregul subarbore al acestuia ca “deconectat”.</li>
</ul>
<p>Pentru a obtine complexitatea optima, marcarea nodurilor ca “deconectat” se face printr-o parcurgere DF in care ne oprim cand ajungem intr-un nod marcat anterior (stim oricum ca intregul lui subarbore este de asemenea marcat deja):</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	deleted<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adj <span class="token operator">:</span> tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>deleted<span class="token punctuation">[</span>adj<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token function">deleteNode</span><span class="token punctuation">(</span>adj<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Iar actualizarea solutiei, parcurgand perechile <code>(x, y)</code> in ordinea sortarii dupa LCA, arata astfel:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deleted<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>deleted<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token function">LCA</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sol<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Folosind algoritmul optim pentru LCA, complexitatea finala este <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N + K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.07153em;" class="mord mathnormal">K</span><span class="mclose">)</span></span></span></span></span>.<br>
Puteti consulta <a href="https://infoarena.ro/job_detail/1564855?action=view-source">aici</a> detaliile de implementare.</p>
<h3 id="atac-infoarena">Atac (<a href="https://infoarena.ro/problema/atac">infoarena</a>)</h3>
<p>Problema ne cere sa raspundem la interogari pentru determinarea muchiei de cost minim aflata pe lantul dintre doua noduri oarecare dintr-un arbore.</p>
<p>Avantajul pe care il avem este ca arborele nu se modifica (daca am avea si update-uri atunci problema ar fi ceva mai grea, si ar trebui sa apelam la tehnici mai avansate - vezi <em>Heavy Path Decomposition</em>).</p>
<p>Ne vom inspira din solutia la problema LCA folosind “stramosi”. Pe langa tabela <code>stramos</code> mai putem calcula si o tabela:<br>
<code>cost[p][nod] :=</code> costul minim al unei muchii aflate pe lantul de la <code>nod</code> pana la <code>stramos[p][nod]</code>.</p>
<p>Calculul celor doua tabele se poate face in paralel:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_LOG<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>cost<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> cost<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>stramos<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stramos<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> stramos<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>stramos<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Fie acum <code>x</code>, <code>y</code> doua noduri si <code>z = LCA(x, y)</code>. Putem determina acum usor care este costul minim al unei muchii de la <code>x</code> la <code>z</code>, sau de la <code>y</code> la <code>z</code>:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">int</span> diff <span class="token operator">=</span> nivel<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">-</span> nivel<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> MAX_LOG <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        diff <span class="token operator">-</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        minimum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minimum<span class="token punctuation">,</span> cost<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        x <span class="token operator">=</span> stramos<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Complexitatea acestei solutii este <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N + M\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">M</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span>, de la precalcularea stramosilor si raspunsul la query-urile de LCA si cost minim in <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mclose">)</span></span></span></span></span>.</p>
<p>O implementare completa a acestei solutii puteti gasi <a href="https://infoarena.ro/job_detail/2971352?action=view-source">aici</a>.</p>
<h3 id="concurs-infoarena">Concurs (<a href="https://infoarena.ro/problema/concurs">infoarena</a>)</h3>
<p>Aceasta problema este o aplicatie simpla a algoritmului de determinare a LCA pentru mai multe perechi de noduri. De aceasta data trebuie doar sa calculati maximul dintre valorile asociate LCA-urilor determinate.</p>
<p>O solutie in <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N + M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathnormal">O</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10903em;" class="mord mathnormal">M</span><span class="mclose">)</span></span></span></span></span> gasiti <a href="https://infoarena.ro/job_detail/1369733?action=view-source">aici</a>.</p>
<h2 id="probleme-suplimentare">Probleme suplimentare</h2>
<h3 id="delay-infoarena">Delay (<a href="https://infoarena.ro/problema/delay">infoarena</a>)</h3>
<p><em>Hint 1:</em> Daca mentinem pentru fiecare nod suma timpilor de la radacina pana la el, raspunsul pentru o interogare <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span><span class="mclose">)</span></span></span></span></span> este: suma timpilor pentru <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">+</span></span></span></span></span> suma timpilor pentru <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathnormal">y</span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">−</span></span></span></span></span> de doua ori suma timpilor pana la parintele LCA-ului.</p>
<p><em>Hint 2:</em> La un update pentru timpul unui nod, se vor modifica toate sumele calculate pentru nodurile din subarborele sau. Daca consideram liniarizarea arborelui, operatia devine update pe interval.</p>
<h3 id="maxdist-infoarena">Maxdist (<a href="https://infoarena.ro/problema/maxdist">infoarena</a>)</h3>
<p><em>Hint 1:</em> Problema este simetrica pentru cele doua bande. Se cere mereu diametrul unui arbore din care fie se elimina frunze (prima banda), fie se adauga frunze (a doua banda). Este mai simpla adaugarea.</p>
<p><em>Hint 2:</em> Cum se modifica diametrul intr-un arbore in care mai adaugam o frunza? Ce se pastreaza? Observati ce se intampla cu capetele diametrului original.</p>
</div>
</body>

</html>